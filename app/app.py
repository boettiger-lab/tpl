import streamlit as st
import leafmap.maplibregl as leafmap
from cng.h3 import *
from utils import *
from ibis import _

st.set_page_config(layout="wide",
                   page_title="TPL Conservation Almanac",
                   page_icon=":globe:")

'''
# TPL Conservation Almanac
A data visualization tool built for the Trust for Public Land
'''

basemaps = leafmap.basemaps.keys()

m = leafmap.Map(style = "positron")

from datetime import time

with st.sidebar:
    b = st.selectbox("Basemap", basemaps)
    m.add_basemap(b)
    st.divider()

    style_choice = st.radio("Color by:", style_options)
    paint = style_options[style_choice]
    st.divider()

    year_range = st.slider(
    "Year", min_value = 1988, max_value = 2025, value=(1988, 2025)
)
    st.divider()

    state_choice = st.selectbox("State", states,index = 6, placeholder='Pick a state')
    one_state = state_choice != 'All'
    counties = get_counties(state_choice)
    if one_state:
        county_choice = st.selectbox("County", counties, index = 0, placeholder='Select a county')
    else:
        county_choice = 'All'
    st.divider()

# get all the ids that correspond to the filter
gdf = filter_data(tpl_table, state_choice, county_choice, year_range)
gdf_landvote = filter_data(landvote_table, state_choice, county_choice, year_range)
unique_ids = gdf.select('fid').distinct().execute()['fid'].to_list()

##### Chatbot stuff 
chatbot_container = st.container()
with chatbot_container:
    llm_left_col, llm_right_col = st.columns([5,1], vertical_alignment = "bottom")
    with llm_left_col:
        with st.popover("üí¨ Example Queries"):
            '''
            Mapping queries: 
            - Show me the most expensive protected site
            - Show me sites owned, managed or sponsored by the Trust for Public Land
            '''

            '''
            Exploratory data queries:
            - Which states have the highest average cost per acre?
            '''
            
            st.info('If the map appears blank, queried data may be too small to see at the default zoom level. Check the table below the map, as query results will also be displayed there.', icon="‚ÑπÔ∏è")
    
    with llm_right_col:
        llm_choice = st.selectbox("Select LLM:", llm_options, key = "llm", help = "Select which model to use.")   
        llm = llm_options[llm_choice]

from pydantic import BaseModel, Field
class SQLResponse(BaseModel):
    """Defines the structure for SQL response."""
    sql_query: str = Field(description="The SQL query generated by the assistant.")
    explanation: str = Field(description="A detailed explanation of how the SQL query answers the input question.")

with open('app/system_prompt.txt', 'r') as file:
    template = file.read()

from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
prompt = ChatPromptTemplate.from_messages([
    ("system", template),
    ("human", "{input}")
]).partial(dialect="duckdb", conservation_almanac = tpl_z8.schema(),
          landvote = landvote_z8.schema(), carbon = carbon_z8.schema(),
          svi = svi_z8.schema(), mobi = mobi_z8.schema())

# chatbot_toggles = {key: False for key in keys}
structured_llm = llm.with_structured_output(SQLResponse)
few_shot_structured_llm = prompt | structured_llm


def run_sql(query,paint):
    """
    Filter data based on an LLM-generated SQL query and return matching IDs.

    Args:
        query (str): The natural language query to filter the data.
        color_choice (str): The column used for plotting.
    """
    output = few_shot_structured_llm.invoke(query)
    sql_query = output.sql_query
    explanation =output.explanation
    if not sql_query: # if the chatbot can't generate a SQL query.
        st.success(explanation)
        return pd.DataFrame({'fid' : []})
    result = con.sql(sql_query).distinct().execute()
    if result.empty :
        explanation = "This query did not return any results. Please try again with a different query."
        st.warning(explanation, icon="‚ö†Ô∏è")
        st.caption("SQL Query:")
        st.code(sql_query,language = "sql") 
        if 'geom' in result.columns:
            return result.drop('geom',axis = 1)
        else: 
            return result
    elif ("fid" and "geom" in result.columns): 
        style = tpl_style(result["fid"].unique().tolist(), paint)
        m.add_pmtiles(pmtiles, style=style, opacity=0.5, tooltip=True, fit_bounds=True)
        m.fit_bounds(result.total_bounds.tolist())    
        result = result.drop('geom',axis = 1) #printing to streamlit so I need to drop geom
    else:   
        st.write(result)  # if we aren't mapping, just print out the data  
    
    with st.popover("Explanation"):
        st.write(explanation)
        st.caption("SQL Query:")
        st.code(sql_query,language = "sql")        
    return result

with chatbot_container:
    with llm_left_col:
        example_query = "üëã Input query here"
        prompt = st.chat_input(example_query, key="chain", max_chars=300)

# new container for output so it doesn't mess with the alignment of llm options 
with st.container():
    if prompt: 
        st.chat_message("user").write(prompt)
        try:
            with st.chat_message("assistant"):
                with st.spinner("Invoking query..."):

                    out = run_sql(prompt,paint)
                    if ("fid" in out.columns) and (not out.empty):
                        ids = out['fid'].unique().tolist()
                        cols = out.columns.tolist()
                        # chatbot_toggles = {
                        #         key: (True if key in cols else value) 
                        #         for key, value in chatbot_toggles.items()
                        #     }
                        # for key, value in chatbot_toggles.items():
                        #     st.session_state[key] = value  # Update session state
                    else:
                        ids = []
        except Exception as e:
            error_message = f"ERROR: An unexpected error has occured with the following query:\n\n*{prompt}*\n\n which raised the following error:\n\n{type(e)}: {e}\n"
            st.warning("Please try again with a different query", icon="‚ö†Ô∏è")
            st.write(error_message)
            st.stop()
##### end of chatbot code 


if 'out' not in locals():
    
    if one_state:
        m.add_pmtiles(pmtiles, style=tpl_style(unique_ids, paint), opacity=0.5, tooltip=True, fit_bounds=True)
    else:        
        m.add_pmtiles(pmtiles, style=tpl_style_default(paint), opacity=0.5, tooltip=True, fit_bounds=True)
    fit_bounds(state_choice, county_choice, m)


m.to_streamlit()
with st.expander("üîç View/download data"): # adding data table  
    if 'out' not in locals():
        st.dataframe(gdf.drop('geom').head(100).execute(), use_container_width = True)  
    else:
        st.dataframe(out, use_container_width = True)

    
public_dollars, private_dollars, total_dollars = tpl_summary(gdf)
# public_delta, private_delta = calc_delta(gdf)
# -

with st.container():
    col1, col2, col3 = st.columns(3)
    col1.metric(label=f"Public", value=f"${public_dollars:,}")
    col2.metric(label=f"Private", value=f"${private_dollars:,}")
    col3.metric(label=f"Total", value=f"${total_dollars:,}")    

st.markdown('#')


col1, col2 = st.columns(2)
with col1:
    gdf_tpl = group_data(gdf, 'Acquisition Cost')
    get_bar(gdf_tpl, style_choice, 'year', 'total_amount', paint,'Year','Acquisition Cost ($)',"Yearly investment ($) in protected area")

with col2:
    gdf_landvote = group_data(gdf_landvote.filter(_.status == 'Pass'), 'Measure Cost')
    get_bar(gdf_landvote, style_choice, 'year', 'total_amount', paint, 'Year','Funds Approved ($)','Yearly funds from conservation ballot measures')

st.divider()

st.markdown('''
## Data Sources
PRIVATE DRAFT.  Developed at UC Berkeley. All data copyright to Trust for Public Land.  See <https://conservationalmanac.org/> for details.
''')

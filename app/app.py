import streamlit as st
from cng.h3 import *
from ibis import _
import importlib
from datetime import time

st.set_page_config(layout="wide",
                   page_title="TPL Conservation Almanac",
                   page_icon=":globe:")

from utils import *

'''
# TPL Conservation Almanac
A data visualization tool built for the Trust for Public Land
'''

pmtiles = get_pmtiles_url() # generate PMTiles url

with st.sidebar:
    leafmap_choice = st.selectbox("Leafmap module", ['maplibregl','foliumap'])

if leafmap_choice == "maplibregl":
    leafmap = importlib.import_module("leafmap.maplibregl")
    m = leafmap.Map(style="positron")
else:
    leafmap = importlib.import_module("leafmap.foliumap")
    m = leafmap.Map(center=[35, -100], zoom=5, layers_control=True, fullscreen_control=True)

basemaps = leafmap.basemaps.keys()

with st.sidebar:
    b = st.selectbox("Basemap", basemaps)
    m.add_basemap(b)
    st.divider()

    style_choice = st.radio("Color by:", style_options)
    paint = style_options[style_choice]
    st.divider()

    year_range = st.slider(
    "Year", min_value = 1988, max_value = 2025, value=(1988, 2025)
)
    st.divider()

    state_choice = st.selectbox("State", states,index = 6, placeholder='Pick a state')
    one_state = state_choice != 'All'
    counties = get_counties(state_choice)
    if one_state:
        county_choice = st.selectbox("County", counties, index = 0, placeholder='Select a county')
    else:
        county_choice = 'All'
    st.divider()

# get all the ids that correspond to the filter
gdf = filter_data(tpl_table, state_choice, county_choice, year_range)
gdf_landvote = filter_data(landvote_table, state_choice, county_choice, year_range)
unique_ids = gdf.select('fid').distinct().execute()['fid'].to_list()

##### Chatbot stuff 
chatbot_container = st.container()
with chatbot_container:
    llm_left_col, llm_right_col = st.columns([5,1], vertical_alignment = "bottom")
    with llm_left_col:
        with st.popover("üí¨ Example Queries"):
            '''
            Mapping queries: 
            - Show me the most expensive protected site
            - Show me sites owned, managed or sponsored by the Trust for Public Land
            '''

            '''
            Exploratory data queries:
            - Which states have the highest average cost per acre?
            '''
            
            st.info('If the map appears blank, queried data may be too small to see at the default zoom level. Check the table below the map, as query results will also be displayed there.', icon="‚ÑπÔ∏è")
    
    with llm_right_col:
        llm_choice = st.selectbox("Select LLM:", llm_options, key = "llm", help = "Select which model to use.")   
        llm = llm_options[llm_choice]

from pydantic import BaseModel, Field
class SQLResponse(BaseModel):
    """Defines the structure for SQL response."""
    sql_query: str = Field(description="The SQL query generated by the assistant.")
    explanation: str = Field(description="A detailed explanation of how the SQL query answers the input question.")

with open('app/system_prompt.txt', 'r') as file:
    template = file.read()

from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
prompt = ChatPromptTemplate.from_messages([
    ("system", template),
    ("human", "{input}")
]).partial(dialect="duckdb", conservation_almanac = tpl_z8.schema(),
          landvote = landvote_z8.schema(), carbon = carbon_z8.schema(),
          svi = svi_z8.schema(), mobi = mobi_z8.schema())

structured_llm = llm.with_structured_output(SQLResponse)
few_shot_structured_llm = prompt | structured_llm


def run_sql(query,paint):
    """
    Filter data based on an LLM-generated SQL query and return matching IDs.

    Args:
        query (str): The natural language query to filter the data.
        color_choice (str): The column used for plotting.
    """
    output = few_shot_structured_llm.invoke(query)
    sql_query = output.sql_query
    explanation =output.explanation
    if not sql_query: # if the chatbot can't generate a SQL query.
        st.success(explanation)
        return pd.DataFrame({'fid' : []})
    result = con.sql(sql_query).distinct().execute()
    if result.empty :
        explanation = "This query did not return any results. Please try again with a different query."
        st.warning(explanation, icon="‚ö†Ô∏è")
        st.caption("SQL Query:")
        st.code(sql_query,language = "sql") 
        if 'geom' in result.columns:
            return result.drop('geom',axis = 1)
        else: 
            return result
    elif ("fid" and "geom" not in result.columns): 
        st.write(result)  # if we aren't mapping, just print out the data  
    
    with st.popover("Explanation"):
        st.write(explanation)
        st.caption("SQL Query:")
        st.code(sql_query,language = "sql")        
    return result

with chatbot_container:
    with llm_left_col:
        example_query = "üëã Input query here"
        prompt = st.chat_input(example_query, key="chain", max_chars=300)

# new container for output so it doesn't mess with the alignment of llm options 
with st.container():
    if prompt: 
        st.chat_message("user").write(prompt)
        try:
            with st.chat_message("assistant"):
                with st.spinner("Invoking query..."):

                    out = run_sql(prompt,paint)
                    if ("fid" in out.columns) and (not out.empty):
                        ids = out['fid'].unique().tolist()
                        cols = out.columns.tolist()
                        bounds = out.total_bounds.tolist()
                        style = tpl_style(ids, paint, pmtiles)
                    else:
                        ids = []
        except Exception as e:
            error_message = f"ERROR: An unexpected error has occured with the following query:\n\n*{prompt}*\n\n which raised the following error:\n\n{type(e)}: {e}\n"
            st.warning("Please try again with a different query", icon="‚ö†Ô∏è")
            st.write(error_message)
            st.stop()
##### end of chatbot code 

# define PMTiles style dict (if we didn't already do so using the chatbot)
if 'style' not in locals(): 
    if one_state:
        # filter to ids in that state 
        style = tpl_style(unique_ids, paint, pmtiles)
    else: 
        # selected all states, so no need to filter 
        style=tpl_style_default(paint, pmtiles)
    bounds = get_bounds(state_choice, county_choice, m)

# add pmtiles to map (using user-specified module)
if leafmap_choice == "maplibregl":
    m.add_pmtiles(pmtiles, style=style, tooltip=True, fit_bounds=True)
    m.fit_bounds(bounds) 
else: 
    m.add_pmtiles(pmtiles, style = style, tooltip = True, zoom_to_layer= False)
    m.zoom_to_bounds(bounds)   

m.to_streamlit()

with st.expander("üîç View/download data"): # adding data table  
    if 'out' not in locals():
        st.dataframe(gdf.drop('geom').head(100).execute(), use_container_width = True)  
    else:
        st.dataframe(out.drop('geom',axis = 1), use_container_width = True)

public_dollars, private_dollars, total_dollars = tpl_summary(gdf)

with st.container():
    col1, col2, col3 = st.columns(3)
    col1.metric(label=f"Public", value=f"${public_dollars:,}")
    col2.metric(label=f"Private", value=f"${private_dollars:,}")
    col3.metric(label=f"Total", value=f"${total_dollars:,}")    

st.markdown('#')

col1, col2 = st.columns(2)
with col1:
    gdf_tpl = group_data(gdf, 'Acquisition Cost')
    get_bar(gdf_tpl, style_choice, 'year', 'total_amount', paint,'Year','Acquisition Cost ($)',"Yearly investment ($) in protected area")

with col2:
    gdf_landvote = group_data(gdf_landvote.filter(_.status == 'Pass'), 'Measure Cost')
    get_bar(gdf_landvote, style_choice, 'year', 'total_amount', paint, 'Year','Funds Approved ($)','Yearly funds from conservation ballot measures')

st.divider()

st.markdown('''
## Data Sources
PRIVATE DRAFT.  Developed at UC Berkeley. All data copyright to Trust for Public Land.  See <https://conservationalmanac.org/> for details.
''')
